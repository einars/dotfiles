#!/usr/bin/env php
<?php

// run in background, monitor watson (https://github.com/TailorDev/Watson)
// and notify every X min 


monitor_watson([
  'notify-interval-mins' => 15,
  'nudge-threshold-mins' => 7,
  'idle-interval-break-mins' => 4,
  'state-file' => getenv('HOME') . '/.config/watson/state',
  'projs-dont-break-when-idle' => [ 'edx' ],
  'tags-dont-break-when-idle' => [ 'video' ],
]);

function xorg_idle_s()
{
  return exec('xprintidle') / 1000;
}

function xorg_active_title()
{
  return exec('xdotool getwindowfocus getwindowname');
}

function work_nudge($state, $opts)
{
  // when no project is happening, but I'm doing something, nudge me

  $in_project = $state['is_running'];
  $nudge_threshold_mins = opt('nudge-threshold-mins', $opts, 5);

  static $active_since = null;
  static $last_nudged = null;
  static $last_title = null;

  if ($in_project) {
    $active_since = null;
    $last_nudged = null;
    $last_title = null;
    return;
  }

  $idle = xorg_idle_s();
  if ($idle > 120) {
    if ($active_since) {
      say('Idle detected: resetting nudge timer.');
      $active_since = null;
      $last_nudged = null;
    }
    return;
  }

  // re-nudge every N min
  if ($last_nudged && (time() - $last_nudged) < 27*60) return;

  if ( ! $active_since ) {
    $active_since = time() - $idle;
    return;
  }

  $active_for_s = (time() - $active_since);
  say(sprintf('Messing around for %s', format_time_s($active_for_s)));
  $title = xorg_active_title();
  if ($title && $title != $last_title) {
    say(sprintf('Messing around: %s', xorg_active_title()));
    $last_title = $title;
  }
  if ($active_for_s > 60 * $nudge_threshold_mins ) {
    nudge($title);
    $last_nudged = time();
  }
}

function nudge($title)
{
  $is_firefox = !! strpos($title, 'Mozilla Firefox');
  $hour = date('H');
  if ($hour > 22 || $hour < 5) {
    say_and_notify(sprintf("It's %s.", date('H:i')));
  } else {
    if ($is_firefox)  {
      say_and_notify("I hope that's not a total junk you're browsing.");
    } else {
      say_and_notify("Don't drift away.");
    }
  }
}

function watson_state($state_file)
{
  $s = json_decode(file_get_contents($state_file), true);

  if ( ! isset($s['project']) ) {
    return [
      'is_running' => false,
      'project' => null,
      'tags' => [],
      'elapsed' => null,
    ];
  }

  $tags = '';
  if (isset($s['tags'])) {
    $tags = $s['tags'];
  } else {
    $tags = [];
  }

  return [
    'is_running' => true,
    'project' => $s['project'],
    'tags' => $tags,
    'elapsed' => (int)((time() - $s['start']) / 60),
  ];

}

function say($message)
{
  printf("%s %s\n", date('Y-m-d H:i'), $message);
}

function say_and_notify($message)
{
  say($message);
  system(sprintf('notify-send -u normal %s', escapeshellarg("Watson\n$message")));
}

function format_time($m)
{
  $h = (int)($m / 60);
  $m = $m % 60;

  if ($h) {
    return sprintf('%d %s and %d %s'
      , $h
      , $h === 1 ? 'hour' : 'hours'
      , $m
      , ($m % 10 === 1 && $m % 100 !== 11 ? 'minute' : 'minutes')
    );
  } else {
    return sprintf('%d %s'
      , $m
      , ($m % 10 === 1 && $m % 100 !== 11 ? 'minute' : 'minutes')
    );

  }
}


function format_time_s($s)
{
  $m = (int)($s / 60);
  $s = $s % 60;
  return sprintf('%dm %02ds', $m, $s);

}


function kill_watson_if_idle($opts)
{
  $idle_interval_break_mins = opt('idle-interval-break-mins', $opts, 8);
  $idle_s = xorg_idle_s();
  if ($idle_s > $idle_interval_break_mins * 60) {
    exec('watson stop');
    say_and_notify("crit: idle stopping watson");
  }
}

function tell_about($state)
{
  $project = $state['project'];
  $time_elapsed = $state['elapsed'];
  if ( $project ) {
    $message = sprintf('Working on %s for %s.', $project, format_time($time_elapsed));
  } else {
    $message = 'Doing nothing, just chill.';
  }
  say($message);
}

function watson_notify($state)
{
  say_and_notify( sprintf('Working on %s for %s.', $state['project'], format_time($state['elapsed'])));
}

function tag_match($state, $test_against)
{
  foreach($state['tags'] as $t) {
    if (in_array($t, $test_against)) return true;
  }
  return false;
}

function proj_match($state, $test_against)
{
  if (in_array($state['project'], $test_against)) return true;
  return false;
}

function monitor_watson($opts)
{

  $notification_interval_min = opt('notify-interval-mins', $opts, 15);
  $state_file                = opt('state-file', $opts, 'state');
  $no_idle_kill_projs        = opt('projs-dont-break-when-idle', $opts, []);
  $no_idle_kill_tags         = opt('tags-dont-break-when-idle', $opts, []);
  // $nudge_threshold_mins = opt('nudge-threshold-mins', $opts, 5);
  // $idle_interval_break_mins = opt('idle-interval-break-mins', $opts, 8);

  if ( ! file_exists($state_file  ) ) {
    die("No watson state file $state_file   found.\n");
  }


  say("Watson now takes some vicodin.");

  $current = watson_state($state_file);
  tell_about($current);

  while (true) {

    if ($current['is_running']
      and ! proj_match($current, $no_idle_kill_projs)
      and ! tag_match($current, $no_idle_kill_tags)
    ) {
      kill_watson_if_idle($opts);
    }

    $s = watson_state($state_file);

    if ($s['project'] !== $current['project']) {
      tell_about($s);
    }

    work_nudge($s, $opts);


    if ($s['is_running'] ) {
      if (($current['elapsed'] !== $s['elapsed']) and ($s['elapsed'] !== 0) and ($s['elapsed'] % $notification_interval_min === 0)) {
        watson_notify($s);
      }
    }

    $current = $s;

    sleep(30);
    // sleep(5);
  }
}

function opt($opt, $opts, $default = null)
{
  if (array_key_exists($opt, $opts)) {
    return $opts[$opt];
  }
  return $default;
}
